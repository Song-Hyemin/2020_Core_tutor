# -*- coding: utf-8 -*-
"""Core_튜터링_5주차.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vyxjwccb2-eVQ8BL4Lm1S1HfcfAcUv8R

# **미로찾기 프로그램 만들기**

(조건)
  1. 벽은 #로, 빈공간은 .으로 둔다.
  2. 캐릭터는 B로 둔다. (Ball의 약자)
  3. 모서리 부분은 전부 #로 막아 놓는다.

(프로그램 설명)
  1. 프로그래밍언어 : Python
  2. 함수를 사용하여 짜임새 있게 구현하였다.
"""

#...
#예시
#...

#####
#..B#
#.#.#
#...#
#####

"""# 프로그램코드

변수 선언
"""

# 벽은 #로, 빈 공간은 .으로, 캐릭터는 B로 둔다.
Block = '#'
Void_area = '.'
Character = 'B'

# 게임판을 새롭게 정의
game_board = []
row = 0            # 행(가로)의 길이
column = 0         # 열(세로)의 길이

# 캐릭터의 자리 또한 새롭게 정의
c_y = 0       # 캐릭터가 처음 시작하는 자리의 y좌표
c_x = 0       # 캐릭터가 처음 시작하는 자리의 x좌표

"""함수 정의부"""

# 게임판을 초기화하는 함수
# 인자로 행의 길이와 열의 길이를 받아서 그 크기만큼 함수 안에서 game_board를 만들고,
# 인자로 캐릭터가 처음 시작하는 자리의 y좌표와 x좌표를 받아서, 그 위치에 캐릭터를 생성한다.
# 리턴값을 함수 밖에 있는 game_board에 대입
# 이 함수의 사용 예시 : game_board = default_game_board(5, 5)
# 이 함수의 사용 예시 : game_board = default_game_board(r, c) (r = 3,c = 7)

def default_game_board(row, column, c_y, c_x):
  game_board = []

  # 빈 공간을 넣는 부분
  for i in range(0,row,1):        # 게임판의 행 (가로)
    a = []
    for j in range(0,column,1):   # 게임판의 열 (세로)
      a.append('.')
    game_board.append(a)

  # 캐릭터의 자리를 정하는 부분
  game_board[c_y][c_x] = 'B'

  # 벽을 넣는 부분
  # 가로줄이 3, 세로줄이 4인 게임판이 있다고 하면 row = 3, column = 4
  # (1) 맨 위 가로줄 (0,0) ~ (0, column)
  # (2) 맨 아래 가로줄 -> (2,0), (2,1), (2,2), (2,3) = (row - 1, 0) ~ (row - 1, column - 1)
  for i in range(0,column,1):
    game_board[0][i] = '#'         # (1) 부분
    game_board[row-1][i] = '#'     # (2) 부분

  # (3) 왼쪽 세로줄 -> (0,0), (1,0), (2,0) = (0,0) ~ (row - 1, 0)
  # (4) 오른쪽 세로줄 -> (0,3), (1,3), (2,3) = (0,column - 1) ~ (row - 1 , column - 1)
  for i in range(0,row,1):
    game_board[i][0] = '#'
    game_board[i][column-1] = '#' 

  # 최종적으로 초기화된 게임판을 출력
  print_game_board(game_board)

  return game_board

# 이중 리스트를 이중 리스트 답게 출력하는 함수를 만들어 보자
def print_game_board(game_board):
  print("이중 리스트를 출력합니다.")
  for i in range(0, len(game_board), 1):      # 가로(행) / len(game_board) = 가로줄의 개수
    for  j in range(0,len(game_board[i]),1):  # 세로(열) / len(game_board[i]) = 세로줄의 개수
      print(game_board[i][j], end=" ")
    print()
  print("이중 리스트의 출력이 끝났습니다.")
  print()

# 테두리에 닿았다면?
# 함수 선언하기

def check(방향, y ,x):

  # 현재 좌표가 테두리를 벗어난다면
  if x < 0 or x >= 5 or y <0 or y >=5 :
    if 방향 == "왼쪽":
      x = 0
    elif 방향 == "오른쪽":
      x = 4
    elif 방향 == "위쪽":
      y = 0
    elif 방향 == "아래쪽":
      y = 4

    print('더이상',방향,'쪽으로 갈 수 없습니다!')

  return y,x

# 벽을 만나기 전까지 한 방향으로 계속 캐릭터를 움직이는 함수
# 재귀함수를 이용해서 만들어 보자
# 인자로 게임판, 캐릭터의 y좌표, 캐릭터의 x좌표, 움직일 방향
# 리턴값은 캐릭터가 벽을 만나기 전까지 한 방향으로 계속 움직인 결과를 보여주는 게임판

def move_not_block(game_board, c_y, c_x, dir):
  # 재귀함수를 잘 알려면 print를 해보면 된다.
  print_game_board(game_board)
  print(c_y,c_x,dir)

  # 함수 안에서만 쓰이는 y,x 변수를 만들자
  y = c_y
  x = c_x

  # 먼저 1칸 이동을 하고
  if dir == '왼쪽':
    x = x - 1
  elif dir == '오른쪽':
    x = x + 1
  elif dir == '위쪽':
    y = y - 1
  elif dir == '아래쪽':
    y = y + 1
  
  # (y,x) : 1칸 이동한 좌표
  # (c_y,c_x) : 이동 전 좌표

  print(y,x)
  # 이동한 자리가 벽인지 확인
  if game_board[y][x] != '#':  # 이동한 자리가 벽이 아니라면
    #이동하기 전 자리는 빈공간('.')으로 두고
    # 이동 후 자리에 캐릭터 표시('B')를 한다.
    game_board[c_y][c_x] = '.'
    game_board[y][x] = 'B'
    return move_not_block(game_board,y,x,dir)

  else:   # 이동한 자리가 벽이라면
    return game_board

"""함수 테스트"""

# default_game_board 함수 테스트
game_board = default_game_board(10,9,5,4)

#game_board[1][3] = 'C'
#print(game_board, len(game_board))
#print(game_board[0], len(game_board[0]))
#print(game_board[1], len(game_board[1]))
#print(game_board[2], len(game_board[2]))

game_board = move_not_block(game_board,5,4,'왼쪽')
print('최종 결과')
print_game_board(game_board)

"""메인 함수"""

# 1. 게임판을 만들어 보자
# 가장 기본적인 방법 - 정의할 때 일일이 하나씩 할당해 주는 방법
lists = [[0,0,0,0,0],
         [0,0,0,0,0],
         [0,0,1,0,0],
         [0,0,0,0,0],
         [0,0,0,0,0]]

print(lists)

# 2. 움직이는 것을 구현하기
# 내가 지금 있는 위치를 표시 (y,x)로 두기
x = 2
y = 2

#lists 초기화시키기
lists = default_doublelist(lists)

방향 = input("방향을 입력하세요: ")

lists[y][x] = 0  # 이동하기 전 위치의 좌표는 0으로 만든다.

# 왼쪽으로 1칸 간다면?  - (2,2)에서 (2,1)로 이동
if 방향 == "왼쪽" :
  x = x - 1

# 오른쪽으로 1칸 간다면?  - (2,2)에서 (2,3)로 이동
elif 방향 == "오른쪽":
  x = x + 1

# 위로 1칸 간다면?  - (2,2)에서 (1,2)로 이동
elif 방향 == "위쪽":
  y = y - 1

# 아래로 1칸 간다면?  - (2,2)에서 (3,2)로 이동
elif 방향 == "아래쪽":
  y = y + 1

print(y,x)

lists[y][x] =1  # lists를 업데이트하는 부분 (이동한 후의 좌표는 1로 만든다.)

print_doublelist(lists)

# 여러 동작 수행하기 - 반복문 (while 문 등 ...)
x = 2
y = 2

while True:
  
  
  방향 = input("방향을 입력하세요. (그만하고 싶으면 \"그만\"이라고 작성하세요.) ")

  lists[y][x] = 0

  # 왼쪽으로 1칸 간다면?  - (2,2)에서 (2,1)로 이동
  if 방향 == "왼쪽" :
    x = x - 1

  # 오른쪽으로 1칸 간다면?  - (2,2)에서 (2,3)로 이동
  elif 방향 == "오른쪽":
    x = x + 1

  # 위로 1칸 간다면?  - (2,2)에서 (1,2)로 이동
  elif 방향 == "위쪽":
    y = y - 1

  # 아래로 1칸 간다면?  - (2,2)에서 (3,2)로 이동
  elif 방향 == "아래쪽":
    y = y + 1

  elif 방향 == "그만":
    break
  
  print(y,x)

  lists[y][x] = 1

  print_doublelist(lists)